diff --git a/src/modules/hyprland/window.cpp b/src/modules/hyprland/window.cpp
index 815fbad8..7d485e8f 100644
--- a/src/modules/hyprland/window.cpp
+++ b/src/modules/hyprland/window.cpp
@@ -21,7 +21,6 @@ Window::Window(const std::string& id, const Bar& bar, const Json::Value& config)
     : AAppIconLabel(config, "window", id, "{title}", 0, true), bar_(bar), m_ipc(IPC::inst()) {
   std::unique_lock<std::shared_mutex> windowIpcUniqueLock(windowIpcSmtx);

-  modulesReady = true;
   separateOutputs_ = config["separate-outputs"].asBool();

   // register for hyprland ipc
@@ -46,10 +45,7 @@ Window::~Window() {
 auto Window::update() -> void {
   std::shared_lock<std::shared_mutex> windowIpcShareLock(windowIpcSmtx);

-  std::string windowName = waybar::util::sanitize_string(workspace_.last_window_title);
-  std::string windowAddress = workspace_.last_window;
-
-  windowData_.title = windowName;
+  std::string windowName = waybar::util::sanitize_string(windowData_.title);

   std::string label_text;
   if (!format_.empty()) {
@@ -165,56 +161,81 @@ auto Window::Workspace::parse(const Json::Value& value) -> Window::Workspace {
 }

 auto Window::WindowData::parse(const Json::Value& value) -> Window::WindowData {
-  return WindowData{.floating = value["floating"].asBool(),
-                    .monitor = value["monitor"].asInt(),
-                    .class_name = value["class"].asString(),
-                    .initial_class_name = value["initialClass"].asString(),
-                    .title = value["title"].asString(),
-                    .initial_title = value["initialTitle"].asString(),
-                    .fullscreen = value["fullscreen"].asBool(),
-                    .grouped = !value["grouped"].empty()};
+  return WindowData{
+      .floating = value["floating"].asBool(),
+      .monitor = value["monitor"].asInt(),
+      .class_name = value["class"].asString(),
+      .initial_class_name = value["initialClass"].asString(),
+      .title = value["title"].asString(),
+      .initial_title = value["initialTitle"].asString(),
+      .fullscreen = value["fullscreen"].asBool(),
+      .grouped = !value["grouped"].empty(),
+  };
 }

 void Window::queryActiveWorkspace() {
   std::shared_lock<std::shared_mutex> windowIpcShareLock(windowIpcSmtx);

-  if (separateOutputs_) {
-    workspace_ = getActiveWorkspace(this->bar_.output->name);
-  } else {
-    workspace_ = getActiveWorkspace();
+  // Get the currently focused window
+  auto focusedWindow = m_ipc.getSocket1JsonReply("activewindow");
+  bool hasFocusedWindow = focusedWindow.isObject() && focusedWindow["mapped"].asBool();
+
+  // Determine if we're on a special workspace by checking the focused window's workspace
+  bool isSpecialWorkspace = false;
+  std::string specialWorkspaceName = "";
+
+  if (hasFocusedWindow && focusedWindow["workspace"].isObject()) {
+    specialWorkspaceName = focusedWindow["workspace"]["name"].asString();
+    if (specialWorkspaceName.find("special:") == 0) {
+      isSpecialWorkspace = true;
+    }
   }

-  focused_ = true;
-  if (workspace_.windows > 0) {
+  // Handle special workspace case
+  if (isSpecialWorkspace) {
+    // Use the focused window's data directly
+    windowData_ = WindowData::parse(focusedWindow);
+    updateAppIconName(windowData_.class_name, windowData_.initial_class_name);
+    focused_ = true;
+
+    // Create a workspace object for this special workspace
+    workspace_ = Workspace{
+        .id = focusedWindow["workspace"]["id"].asInt(),
+        .windows = 1, // We know at least this window exists
+        .last_window = focusedWindow["address"].asString(),
+        .last_window_title = focusedWindow["title"].asString()
+    };
+
+    // Get all clients to compute workspace properties
     const auto clients = m_ipc.getSocket1JsonReply("clients");
     if (clients.isArray()) {
-      auto activeWindow = std::ranges::find_if(
-          clients, [&](Json::Value window) { return window["address"] == workspace_.last_window; });
-
-      if (activeWindow == std::end(clients)) {
-        focused_ = false;
-        return;
-      }
-
-      windowData_ = WindowData::parse(*activeWindow);
-      updateAppIconName(windowData_.class_name, windowData_.initial_class_name);
+      // Filter windows that belong to this special workspace
       std::vector<Json::Value> workspaceWindows;
       std::ranges::copy_if(clients, std::back_inserter(workspaceWindows), [&](Json::Value window) {
-        return window["workspace"]["id"] == workspace_.id && window["mapped"].asBool();
+        return window["workspace"].isObject() &&
+               window["workspace"]["name"].asString() == specialWorkspaceName &&
+               window["mapped"].asBool();
       });
+
+      workspace_.windows = workspaceWindows.size();
+
+      // Compute workspace properties
       swallowing_ = std::ranges::any_of(workspaceWindows, [&](Json::Value window) {
         return !window["swallowing"].isNull() && window["swallowing"].asString() != "0x0";
       });
+
       std::vector<Json::Value> visibleWindows;
       std::ranges::copy_if(workspaceWindows, std::back_inserter(visibleWindows),
-                           [&](Json::Value window) { return !window["hidden"].asBool(); });
+                          [&](Json::Value window) { return !window["hidden"].asBool(); });
+
       solo_ = 1 == std::count_if(visibleWindows.begin(), visibleWindows.end(),
-                                 [&](Json::Value window) { return !window["floating"].asBool(); });
+                                [&](Json::Value window) { return !window["floating"].asBool(); });
+
       allFloating_ = std::ranges::all_of(
           visibleWindows, [&](Json::Value window) { return window["floating"].asBool(); });
+
       fullscreen_ = windowData_.fullscreen;

-      // Fullscreen windows look like they are solo
       if (fullscreen_) {
         solo_ = true;
       }
@@ -225,20 +246,70 @@ void Window::queryActiveWorkspace() {
         soloClass_ = "";
       }
     }
-  } else {
-    focused_ = false;
-    windowData_ = WindowData{};
-    allFloating_ = false;
-    swallowing_ = false;
-    fullscreen_ = false;
-    solo_ = false;
-    soloClass_ = "";
+  }
+  // Handle regular workspace case
+  else {
+    if (separateOutputs_) {
+      workspace_ = getActiveWorkspace(this->bar_.output->name);
+    } else {
+      workspace_ = getActiveWorkspace();
+    }
+
+    focused_ = true;
+    if (workspace_.windows > 0) {
+      const auto clients = m_ipc.getSocket1JsonReply("clients");
+      if (clients.isArray()) {
+        auto activeWindow = std::ranges::find_if(
+            clients, [&](Json::Value window) { return window["address"] == workspace_.last_window; });
+
+        if (activeWindow == std::end(clients)) {
+          focused_ = false;
+          return;
+        }
+
+        windowData_ = WindowData::parse(*activeWindow);
+        updateAppIconName(windowData_.class_name, windowData_.initial_class_name);
+        std::vector<Json::Value> workspaceWindows;
+        std::ranges::copy_if(clients, std::back_inserter(workspaceWindows), [&](Json::Value window) {
+          return window["workspace"]["id"] == workspace_.id && window["mapped"].asBool();
+        });
+        swallowing_ = std::ranges::any_of(workspaceWindows, [&](Json::Value window) {
+          return !window["swallowing"].isNull() && window["swallowing"].asString() != "0x0";
+        });
+        std::vector<Json::Value> visibleWindows;
+        std::ranges::copy_if(workspaceWindows, std::back_inserter(visibleWindows),
+                            [&](Json::Value window) { return !window["hidden"].asBool(); });
+        solo_ = 1 == std::count_if(visibleWindows.begin(), visibleWindows.end(),
+                                  [&](Json::Value window) { return !window["floating"].asBool(); });
+        allFloating_ = std::ranges::all_of(
+            visibleWindows, [&](Json::Value window) { return window["floating"].asBool(); });
+        fullscreen_ = windowData_.fullscreen;
+
+        // Fullscreen windows look like they are solo
+        if (fullscreen_) {
+          solo_ = true;
+        }
+
+        if (solo_) {
+          soloClass_ = windowData_.class_name;
+        } else {
+          soloClass_ = "";
+        }
+      }
+    } else {
+      focused_ = false;
+      windowData_ = WindowData{};
+      allFloating_ = false;
+      swallowing_ = false;
+      fullscreen_ = false;
+      solo_ = false;
+      soloClass_ = "";
+    }
   }
 }

 void Window::onEvent(const std::string& ev) {
   queryActiveWorkspace();
-
   dp.emit();
 }

